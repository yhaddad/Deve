  /// \file EventDisplay.cc
/*
 *
 * EventDisplay.cc source template generated by fclass
 * Creation date : mar. sept. 24 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Et� R�mi
 * @version
 * @copyright
 *
 *
 */


#include "EventDisplay.hh"

using namespace std;
using namespace EVENT;
using namespace IOIMPL;

namespace deve {

	TEveManager *EventDisplay::eveManager = 0;


	EventDisplay::EventDisplay()
		: isInitialized( false ) {

		lcReader = LCFactory::getInstance()->createLCReader();
		eventLoader = new EventLoader();
	}

	EventDisplay::~EventDisplay() {

		delete eventLoader;
		eventLoader = 0;
		TEveManager::Terminate();
		eveManager = 0;
	}

	void EventDisplay::initialize() {

		if( isInitialized )
			return;

		eveManager = TEveManager::Create();
		isInitialized = true;
	}

	void EventDisplay::registerObjectLoader( ObjectLoader *objLoader ) {

		if( objLoader == 0 )
			return;

		if( objectLoaders.find( objLoader->getObjectType() ) != objectLoaders.end() )
			return;

		objectLoaders[ objLoader->getObjectType() ] = objLoader;
		return;
	}

	void EventDisplay::pause() {

		#ifdef __unix__
			std::cout << "Press return to continue ..." << std::endl;
			int flag = fcntl(1, F_GETFL, 0);

			int key = 0;
			while(true)
			{
				gSystem->ProcessEvents();
				fcntl(1, F_SETFL, flag | O_NONBLOCK);
				key = getchar();

				if((key == '\n') || (key == '\r'))
					break;

				usleep(1000);
			}

			fcntl(1, F_SETFL, flag);
		#else
			std::cout << "EventDisplay::pause() is only implemented for unix operating systems." << std::endl;
		#endif
	}

	void EventDisplay::loadLcioFile( const std::string &fileName ) {

		lcReader->open( fileName );
		currentEvent = lcReader->readNextEvent();
		eventLoader->loadEvent( currentEvent , objectLoaders );
	}



	void EventDisplay::loadEvent( int runNb , int evtNb ) {

		LCEvent *previousEvent = currentEvent;

		try {
			currentEvent = lcReader->readEvent( runNb , evtNb );
		}
		catch( IOException &e ) {
			cerr << "LCIO exception caught while loading event "+evtNb+" , run "+runNb+" : " << e.what() << endl;
			currentEvent = previousEvent;
			previousEvent = 0;
		}
		eventLoader->loadEvent( currentEvent , objectLoaders );
	}



}  // namespace 

