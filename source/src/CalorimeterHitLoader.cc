  /// \file CalorimeterHitLoader.cc
/*
 *
 * CalorimeterHitLoader.cc source template generated by fclass
 * Creation date : mar. sept. 24 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Et� R�mi
 * @version
 * @copyright
 *
 *
 */


#include "CalorimeterHitLoader.hh"


// root includes
#include "TVector3.h"
#include "TEveCompound.h"
#include "TEveRGBAPalette.h"
#include "TStyle.h"

// deve includes
#include "EventDisplay.hh"

using namespace std;
using namespace EVENT;

namespace deve {


	CalorimeterHitLoader::~CalorimeterHitLoader() {

	}

	void CalorimeterHitLoader::loadObjectsFromLCCollection( LCCollection *lcCollection , const string &colName ) {

		TEveManager *eveManager = EventDisplay::getEveManager();
		if( eveManager == 0 )
			return;

		if( lcCollection == 0 )
			throw invalid_argument("LCCollection is a NULL pointer!");

		string collectionType = lcCollection->getTypeName();

		if( collectionType != objectType ) {

			string message = "LCCollection with bad type. Provided : "+collectionType+" , expected : objectType";
			throw invalid_argument( message.c_str() );
		}

		int nbOfHits = lcCollection->getNumberOfElements();
		TEveCompound* calorimeterHits = new TEveCompound();

		for( unsigned int h=0 ; h<nbOfHits ; h++ ) {

			CalorimeterHit *caloHit = 0;
			caloHit = dynamic_cast<CalorimeterHit *> ( lcCollection->getElementAt( h ) );

			// if dynamic cast fails
			if( caloHit == 0 )
				throw runtime_error("Can't CalorimeterHit object from LCCollection. dynamic_cast failed");


			TEveBoxSet* hitCellBox = this->buildCaloHitCell( caloHit , colName );
			hitCellBox->DigitColor( 1 );
			hitCellBox->DigitValue( 1.0 );
			hitCellBox->RefitPlex();
			hitCellBox->SetPickable(kTRUE);

			calorimeterHits->AddElement( hitCellBox );
		}

		eveManager->AddElement( calorimeterHits );
	}


	void CalorimeterHitLoader::loadObjects( void * ) {

		// Does nothing. See loadObjectsFromLCCollection(*) method
		return;
	}


	float CalorimeterHitLoader::getCellSizeFactor( const std::string &colName ) {

		// simple return for the moment.
		return 10.0;  // in mm.

	}

	TEveBoxSet *CalorimeterHitLoader::buildCaloHitCell( CalorimeterHit *caloHit , const std::string &colName ) {

		string boxSetName = "CalorimeterHits_"+colName;
		TEveBoxSet *hitBoxCell = new TEveBoxSet( boxSetName.c_str() );

		UTIL::CellIDDecoder<CalorimeterHit> cellIdDecoder( decoderString );
		float positionX = caloHit->getPosition()[0];
		float positionY = caloHit->getPosition()[1];
		float positionZ = caloHit->getPosition()[2];
		TVector3 hitPosition( positionX , positionY , positionZ );
		float energy = caloHit->getEnergy();         // for the color
		int module = cellIdDecoder(caloHit)["M"];
		int stave = cellIdDecoder(caloHit)["S-1"];   // for cell orientation
		float scaleFactor = this->getCellSizeFactor( colName );
		TVector3 scaleVector( scaleFactor , scaleFactor , scaleFactor*0.1 );

		gStyle->SetPalette(1,0);
		TEveRGBAPalette* palette = new TEveRGBAPalette( 0 , 100 );
		hitBoxCell->SetPalette( palette );
		hitBoxCell->SetMainTransparency( 0 );
		hitBoxCell->Reset( TEveBoxSet::kBT_FreeBox , kFALSE , 64 );

		const float degreeToRadian = 1.74532925199432781e-02;
		float deltaX1 = 0;
		float deltaY1 = 0;
		float deltaZ1 = 0;
		float deltaX2 = 0;
		float deltaY2 = 0;
		float deltaZ2 = 0;
		float phiAngle = 0;

		// type 0 -> EcalBarrel
		if( colName.find("EcalBarrel") != string::npos || colName.find("ECALBarrel") != string::npos ) {

	    	if( stave == 2 || stave == 6 )
	    		phiAngle = 0;

	    	if( stave == 0 || stave == 4 )
	    		phiAngle = 90*degreeToRadian;

	    	if( stave == 3 || stave == 7 )
	    		phiAngle = 45*degreeToRadian;

	    	if( stave == 1 || stave == 5 )
	    		phiAngle = 135*degreeToRadian;

		    deltaX1 = -0.5*(scaleVector(0)*sin(phiAngle)+scaleVector(2)*cos(phiAngle));
		    deltaY1 = 0.5*(scaleVector(0)*cos(phiAngle)-scaleVector(2)*sin(phiAngle));
		    deltaX2 = -0.5*(scaleVector(0)*sin(phiAngle)-scaleVector(2)*cos(phiAngle));
		    deltaY2 = 0.5*(scaleVector(0)*cos(phiAngle)+scaleVector(2)*sin(phiAngle));
		    deltaZ1 = scaleVector(1)/2.0;
		    deltaZ2 = deltaZ1;

		}
		// type 1 -> TCMTCalo or HCalBarrel
		else if( colName.find("Tcmt") != string::npos || colName.find("TCMT") != string::npos ) {

			if( hitPosition.Phi() > 0 )
				phiAngle = 2*M_PI/stave * int(hitPosition.Phi()*stave/2/M_PI+0.5);
			else
				phiAngle = 2*M_PI/stave * int(hitPosition.Phi()*stave/2/M_PI-0.5);

		    deltaX1 = -0.5*(scaleVector(0)*sin(phiAngle)+scaleVector(2)*cos(phiAngle));
		    deltaY1 = 0.5*(scaleVector(0)*cos(phiAngle)-scaleVector(2)*sin(phiAngle));
		    deltaX2 = -0.5*(scaleVector(0)*sin(phiAngle)-scaleVector(2)*cos(phiAngle));
		    deltaY2 = 0.5*(scaleVector(0)*cos(phiAngle)+scaleVector(2)*sin(phiAngle));
		    deltaZ1 = scaleVector(1)/2.0;
		    deltaZ2 = deltaZ1;
		}
		// type -1 -> EndCap (Ecal and Hcal) and others
		else {

			deltaX1 = -1*scaleVector(0)/2.0;
			deltaX2 = -1*deltaX1;
			deltaY1 = -1*scaleVector(1)/2.0;
			deltaY2 = deltaY1;
			deltaZ1 = scaleVector(2)/2.0;
			deltaZ2 = deltaZ1;
		}

		float hitCoordinates[24] = { hitPosition(0)+deltaX1, hitPosition(1)+deltaY1, hitPosition(2)-deltaZ1,
									  hitPosition(0)+deltaX1, hitPosition(1)+deltaY1, hitPosition(2)+deltaZ1,
									  hitPosition(0)-deltaX2, hitPosition(1)-deltaY2, hitPosition(2)+deltaZ1,
									  hitPosition(0)-deltaX2, hitPosition(1)-deltaY2, hitPosition(2)-deltaZ1,
									  hitPosition(0)+deltaX2, hitPosition(1)+deltaY2, hitPosition(2)-deltaZ1,
									  hitPosition(0)+deltaX2, hitPosition(1)+deltaY2, hitPosition(2)+deltaZ1,
									  hitPosition(0)-deltaX1, hitPosition(1)-deltaY1, hitPosition(2)+deltaZ1,
									  hitPosition(0)-deltaX1, hitPosition(1)-deltaY1, hitPosition(2)-deltaZ1 };

		hitBoxCell->AddBox( hitCoordinates );
		return hitBoxCell;
	}


}  // namespace 

